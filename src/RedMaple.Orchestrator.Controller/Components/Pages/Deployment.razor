@page "/deployments/{slug}"
@using Humanizer
@using RedMaple.Orchestrator.Controller.Domain.Aggregations
@using RedMaple.Orchestrator.Controller.Domain.Deployments
@using RedMaple.Orchestrator.Controller.Domain.Metrics.ContainerMetrics
@using RedMaple.Orchestrator.Controller.Domain.Metrics.Models
@using RedMaple.Orchestrator.Controller.ViewModels
@using System.Globalization
@inject IDeploymentManager deploymentManager
@inject IContainerStatsUpdateProvider containerStatsUpdateProvider
@inject ContainerStatsAggregator containerStatsAggregator
@implements IDisposable
@rendermode InteractiveServer

<MudText Typo="Typo.h3">@Slug</MudText>

<MudText Typo="Typo.h6">Logs</MudText>
<div class="container-logs">
    @foreach (var deployedContainer in _containers)
    {
        <div>
            <div>@deployedContainer.Container.Name</div>
            <ContainerLogView NodeId="@deployedContainer.Node.Id" ContainerId="@deployedContainer.Container.Id" />
        </div>
    }
</div>

<div class="container-charts">
    <MudCard Class="pa-3">
        <MudText Typo="Typo.caption">@_cpuHeader</MudText>
        <ContainerStatsChart SeriesName="CPU (%)" Data="@_cpuStats"></ContainerStatsChart>
    </MudCard>

    <MudCard Class="pa-3">
        <MudText Typo="Typo.caption">@_memoryHeader</MudText>
        <ContainerStatsChart SeriesName="Memory (MB)" Data="@_memoryUsage"></ContainerStatsChart>
    </MudCard>
</div>


@code {
    [Parameter]
    public string Slug { get; set; } = null!;

    private IReadOnlyList<ContainerStatsAggregation> _containers = new List<ContainerStatsAggregation>();
    private IReadOnlyCollection<DoubleTime> _cpuStats = Array.Empty<DoubleTime>();
    private IReadOnlyCollection<DoubleTime> _memoryUsage = Array.Empty<DoubleTime>();
    private string? _monitorContainerId = null;
    private string _memoryHeader = "Memory Usage";
    private string _cpuHeader = "CPU (%)";

    protected override async Task OnParametersSetAsync()
    {
        //var deployment = await deploymentManager.GetDeploymentBySlugAsync(Slug);
        await RefreshStatsAsync();
    }

    private async Task RefreshStatsAsync()
    {
        _containers = await containerStatsAggregator.GetDeployedContainersAsync(Slug);
        if (_containers.Count > 0)
        {
            var container = _containers[0];
            _monitorContainerId = container.Container.Id;
            if(container.Stats is null)
            {
                return;
            }

            var cpuHistory = container.Stats.CpuPercentHistory;
            if (cpuHistory is not null)
            {
                _cpuStats = cpuHistory;
                _cpuHeader = $"CPU {Math.Round(container.Stats.CpuPercent)}%";

            }

            var memoryUsageHistory = _containers[0].Stats?.MemoryUsageHistory;
            if (memoryUsageHistory is not null)
            {
                _memoryUsage = memoryUsageHistory.Select(x=>new DoubleTime(x.Time, x.Value / (1024.0*1024.0))).ToList();
                _memoryHeader = "Memory Usage " + container.Stats.MemoryUsage.Bytes().Humanize(CultureInfo.InvariantCulture);
            }
        }
    }

    private async void OnContainerStatsUpdated(object? sender, string containerId)
    {
        if(_monitorContainerId == containerId)
        {
            try
            {
                await RefreshStatsAsync();
                await InvokeAsync(() =>
                {
                    this.StateHasChanged();
                });
            }
            catch { }
        }
    }

    protected override void OnInitialized()
    {
        containerStatsUpdateProvider.ContainerStatsUpdated += OnContainerStatsUpdated;
        base.OnInitialized();
    }

    public void Dispose()
    {
        containerStatsUpdateProvider.ContainerStatsUpdated -= OnContainerStatsUpdated;
    }
}
